[プログラムの説明]
<演習1>
Carクラス、Dayクラスをそれぞれ教科書通りに作る。次に、Carクラスの派生クラスとしてOdometerCarクラスを作る。派生クラス内で総走行距離の情報を含めたコンストラクタを宣言する。この際、Carクラスのコンストラクタをsuper()によって呼び出して名前、幅、高さ、長さ、残り燃料、購入日、情報を初期化して、派生クラスの総走行距離を表すインスタンスも初期化する。また、Carクラスのmoveメソッドを呼び出す派生クラスのメソッドであるmoveを作り、suoer.moveの返す結果によって場合分けをする。今回は残り燃料を表す、fuelが0以下になるとfalse、それまではtrueを返すので、trueの場合はその時点のx,y座標、総走行距離を出力する。falseの場合は燃料がなくなったと出力してその時点でプログラムを終了する。OdometerCarTesterクラスではOdometerCarクラスの変数aを作ってputSpec()メソッドで名前などの情報を出力する。そして、aで手に入れた燃料が0以下になるまで、移動したいx,y座標の距離をキーボードから入力できるようにして、その入力された数字を引数としてa.moveメソッド実行する。

<追記>総走行距離の初期値を0に固定し、moveメソッドにより変化するようにした。また、その時点でのx,yの座標をmoveメソッドの中でなくテスタークラスで行い、moveメソッドは燃料を検査して移動（座標値の更新）するだけのものとした。

<演習2>
前の課題で作ったAccountクラスの文字列化メソッドに定期預金口座の情報を加えるためにtimeBalanceの値が0かどうかで定期預金を出力するか決めるようにtoStringメソッドを改良する。また、Accountクラスの派生クラスであるTimeAccountクラスを作り、定期預金を含んだ口座名義等のインスタンスを初期化するコンストラクタをsuper()を使うことにより実装する。TimeAccountTester2クラスでは、Accountクラス、timeAccountクラスどちらでも引数に取れるようなメソッドcomBalanceを作り、引数がTimeAccountクラスのインスタンスかAccountクラスのインスタンスかで場合分けをする。もしAccountクラスのインスタンスであれば，普通預金を比較の対象とし，TimeAccountクラスのインスタンスであれば普通預金と定期預金の合計額を比較対象とした。そして、その比較の結果によって値を返し、その値によって同じ、adachiさんの方が多い、tanakaさんの方が多い、のように出力が変わるようにする。最後にAccountクラスで作ったtoStringメソッドを使うことでそれぞれの口座情報を出力する。

<追記>もともとのAccountクラスを変えずにtoStringメソッドをオーバライドし、TimeAccountクラスに定期預金の情報を含んだtoStringメソッドを実装した。また、定期預金の情報は、TimeAccountメソッドでしか持たないようにし、ゲッタを作った。

<課題1>
三角形の三辺の長さを表すフィールドa,b,cを作り、三角形の三辺の長さを文字列化してかえすtoStringメソッドを作る。次に、3つの引数が三角形の辺の長さとしてありえる値である場合のみ三角形の各辺の値を更新するメソッドsetを作成する。Triangleクラスの派生クラスであるIsoscelesTriangleクラスでは、三角形の３辺の長さ、二等辺三角形の斜辺、底辺を出力するtoStringメソッドを基底クラスのtoStringメソッドを使い、実装する。また、3つの引数が二等辺三角形の辺の長さとしてありえる値である場合のみ三角形の各辺の値を更新するメソッドsetを作成する。IsoscelesTriangleクラスの派生クラスであるEquilateralTriangleクラスでは、三角形の３辺の長さ、正三角形の辺の長さを出力するtoStringメソッドを基底クラスのtoStringメソッドを使い、実装する。また、3つの引数が正三角形の辺の長さとしてありえる値である場合のみ三角形の各辺の値を更新するメソッドsetを作成する。TrianglesTesterクラスでは三種類のクラスのインスタンスをそれぞれ作り、各インスタンスの情報を表示し、また、３辺の長さの値を三辺が異なる三角形、二等辺三角形、正三角形、三角形にならない形となるようそれぞれsetを使い更新して、二等辺三角形と正三角形が更新される場合と更新されない場合、二等辺三角形が更新されるが正三角形が更新されない場合を含み、出力されるようにした。
<課題2>
x,yの範囲を決め、次元配列のフィールドにより，1画面分のプロットを保存し、すべての文字を' 'にするメソッドclear()とプロットの内容を表示するメソッドprintln()を作る。次に、char型のフィールドsymbolをつくり、初期化するコンストラクタをつくる。また、int xの離散化された関数値yを返すインスタンスメソッドgetYをつくり、メソッドgetYの値に基づいてグラフをプロットするメソッドplot()を作る。PlotGraphのサブクラスのSinPGraphクラスでは、波形の振幅、周期を表すフィールドamplitude,periodを作る。また、symbolを含むそれらのフィールドを更新するコンストラクタを実装し、amplitude,periodのセッタ、ゲッタを作る。最後にgetYメソッドで正弦波を表す式から値を返し、正弦波関数をプロットできるようにする。SinPGraphのサブクラスのSawToothPGraphクラスでは、先程のフィールドを更新するコンストラクタを作り、getY()メソッドで、floor関数を使ったのこぎり波を表す式から値を返し、のこぎり波をプロットできるようにする。mainメソッドを含むPlotGraphTesterクラスでは、三種類のクラスのインスタンスをそれぞれ作り、正弦波、のこぎり波をプロットする。また、振幅と周期を変えて同じくプロットする。

<追記>のこぎり波の関数が振幅に対応できるようにして、かつ正しい位置にくるようにした。

[まとめ]
ただ単にクラスをコピペ拡張しただけだと、親クラスのインスタンスを引数にもつメソッドで子クラスのインスタンスを引数にすることができず、互換性がない。そこでextendsを使うことによって、派生クラスを作り引数に互換性をもつメソッドを作ることができる。しかし、クラスの派生によってコンストラクタは継承されない。そこで、super()により、親クラスのコンストラクタを呼び出すことができるので、それによってインスタンスを更新することができる。また、同じコードを書かなくて良くなり、より効率的にプログラムを実行することができるようになる。さらに、クラス継承により、互換クラス内でのメソッドは上位クラスのメソッドをオーバーライドすることにより、呼び出しを統一することができる。
[理解度]
B
[感想]
オーバーライドをすることで、条件によって上書きしたい時だけ上書きする、ということができるのはより効率的にプログラムが書くのに役立つと思った。
[特記事項]

