<問題19-1>
(1)x 0以上99以下の添字を使うことができる。
(2)x sizeメソッドを使う。lengthメソッドは存在しない。
(3)x get(99)というメソッド呼び出しを行う。
(4)o 
(5)x valueSetではなくvaluesメソッドを使う。
<問題19-2>
(1)コンパイルエラーになる。string型の要素のリストであるのでint型の要素は追加できない。
(2)Chrisである。get(2)で表示されるのはChris。
(3)3 格納している要素の数が3であるから。
[プログラムの説明]
<練習問題19-2>
addメソッドを使ってlistにDianaとElenを追加する。また、listと同じく、新たなArrayListクラスのインスタンスlistRevをつくり、listから要素を参照して、listRevにaddメソッドを使って追加していく。最後に、listRevの要素を出力して処理を終わる。
<練習問題19-3>
MyStringArrayListクラスでは、まず、要素の個数を表すフィールドINSITIAL_CAPACITY、String型の配列を表すフィールドar、その要素数を表すフィールドszをつくる。そして、要素を追加する(arが一杯だったら長さを2倍にした配列をつくりそこに格納する)メソッドaddをつくる。次に、要素を参照するメソッドであるgetメソッドをつくる、この時、添え字が範囲外なら，例外
IndexOutOfBoundsExceptionを投げる。最後に、要素数を返すメソッドsize()をつくる。MyStringArrayListTesterクラスでは、先ほど作ったメソッドを使い、listに要素を追加して出力する。また、要素数がINSITIAL_CAPACITYを超えても要素が追加できているか確かめるために、追加してlistを出力する。次に、sizeメソッドを使い、要素数を求め、最後に、IndexOutOfBoundsExceptionをcatchした時の処理を行い、正常に行われるか確かめる。
<課題1>
まず、RevPolishNotationCalcクラスでは、メインメソッドで、まずScannerを使って標準入力を読み取る。そしてhasNextLineで入力があるうちはループする処理内で、calcメソッドを呼び出し、戻り値を出力する。また、InvalidEquation、InvalidTermが投げられたときの処理を行う。
calcメソッド内では、スタックとしてLinkedList<Double>を使い、入力文字列を空白で分割し配列に変換する。そして、配列の要素が数値であるかをNumberメソッドで判定して、数値であればスタックにつむ。また、配列の要素が（+, -, *, /）であれば、operatorメソッドを呼び出す。配列の要素がそのどちらでもない場合は、InvalidTermを投げる。この際、Numberメソッド内ではそれがdouble型かを判定して、operatorメソッド内では+, -, *, /のどれであるかを判定して、それぞれに対応した計算をして計算結果をスタックに追加する。
<課題2>
まず、メインメソッド内で、コマンドライン引数が不適切な場合は、正しい使用法をかいて処理を中断する。次に、コマンドライン引数から取得した基数と回数をそれぞれ表すフィールドbaseとcountをつくる。そして、基数が2から16かつ回数が0以上から判定して、正しいならprintメソッドを呼び出す。また、NumberFormatExceptionが投げられた場合の処理も行う。printメソッド内では、まずStringオブジェクトを要素にもつ双方向リストdequeを作成し、addメソッドでdequeに初期値として1を追加する。そして、dequeから値を取り出して出力し、dequeの最も後ろにある数を基数の進数にしたものに1を足して、dequeに追加していく処理を基数回行う処理をcount回行う。
[まとめ]
配列とArrayListの違いについては、配列は固定サイズのデータ構造で、一度作成するとサイズを変更することはできない。一方、ArrayListはサイズが動的に変化するリストであり、例えばaddメソッド等を使い、必要に応じて要素を追加・削除することができる。ArrayListは多くのメソッドがあり、配列よりも簡単にデータ操作をすることができる。次に、イテレータや拡張forループの利便性に関しては、まず、イテレータはhasNext()、next()等のメソッドをもち、要素に対して操作をしたり、確認したりすることが容易にできる。また、イテレータを使うことで数え上げを行う際に、配列かArrayListであるか等を意識する必要が無くなりより簡単に実装することができる。次に、拡張forループに関しては、配列やコレクションのすべての要素に対して容易にアクセスできるので、コードをより簡単に、可読性をより向上することが可能である。また、LinkedListは、双方向連結リストであり、全ての要素が前後の要素への参照を持つので、特定の位置への要素の追加や削除が簡単にできる。そして、HashSetは、要素の順序を意識しないので単に特定の要素があるかどうかを判定するのに使われる。最後に、HashMapは要素に対し特定のキーを対応づけて管理するデータ構造であるので、任意の参照型を使うことができる。これにより、さまざまな種類のデータを柔軟に扱うことができ、特定の要素の検索もキーを使うことにより迅速に行うことができる。
[理解度]
B
[感想]

[特記事項]
